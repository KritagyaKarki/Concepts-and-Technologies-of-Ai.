# -*- coding: utf-8 -*-
"""workshop1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pkLyMLxcbdeeORcCg84GP6lZvoEq_X6j
"""

import numpy as np

# 1.
empty_array = np.empty((2, 2))
print("Empty Array:\n", empty_array)

# 2.
ones_array = np.ones((4, 2))
print("\nAll-One Array (4x2):\n", ones_array)

# 3.
filled_array = np.full((3, 3), 7)
print("\nFilled Array (3x3) with 7:\n", filled_array)

# 4.
array = np.array([[1, 2, 3], [4, 5, 6]])
zeros_like_array = np.zeros_like(array)
print("\nZeros Like Array:\n", zeros_like_array)

# 5.
ones_like_array = np.ones_like(array)
print("\nOnes Like  Array:\n", ones_like_array)

# 6.
new_list = [1, 2, 3, 4]
array_from_list = np.array(new_list)
print("\nArray from List:\n", array_from_list)



import numpy as np

# 1. Create an array with values ranging from 10 to 49
a = np.arange(10, 50)
print("1. Array 10 to 49:\n", a)

# 2. Create a 3x3 matrix with values 0 to 8
b = np.arange(9).reshape(3, 3)
print("2.3x3 matrix 0 to 8:\n", b)

# 3. Create a 3x3 identity matrix
c = np.eye(3)
print("3.Identity matrix:\n", c)

# 4. Create a random array of size 30 and find the mean
d = np.random.random(30)
print("4.Random array mean:\n", d.mean())

# 5. 10x10 random array → min & max
e = np.random.random((10, 10))
print("5.Min value:", e.min())
print("Max value:", e.max())

# 6. Zero array of size 10, replace 5th element with 1
f = np.zeros(10)
f[4] = 1
print("6.Zero array with 5th element = 1:\n", f)

# 7. Reverse array
arr = np.array([1, 2, 0, 0, 4, 0])
g = arr[::-1]
print("7. Reversed array:\n", g)

# 8. 2D array with 1 border, 0 inside
h = np.ones((5, 5))
h[1:-1, 1:-1] = 0
print("8. Border 1, inside 0:\n", h)

# 9. 8x8 checkerboard pattern
i = np.zeros((8, 8))
i[1::2, ::2] = 1
i[::2, 1::2] = 1
print("9. 8x8 checkerboard:\n", i)



import numpy as np

# Given arrays
x = np.array([[1, 2], [3, 5]])
y = np.array([[5, 6], [7, 8]])
v = np.array([9, 10])
w = np.array([11, 12])

# 1. Add the two arrays
add_xy = x + y
print("1. x + y:\n", add_xy)

# 2. Subtract the two arrays
sub_xy = x - y
print("\n2. x - y:\n", sub_xy)

# 3. Multiply the array with any integer (e.g., 3)
mult_x = x * 3
print("\n3. x * 3:\n", mult_x)

# 4. Square of each element of the array
square_x = x ** 2
print("\n4. Square of x:\n", square_x)

# 5. Dot products
dot_vw = np.dot(v, w)
dot_xv = np.dot(x, v)
dot_xy = np.dot(x, y)
print(" \nDot product v·w:", dot_vw)
print(" Dot product x·v:\n", dot_xv)
print(" Dot product x·y:\n", dot_xy)

# 6. Concatenate x and y along rows (vertical stack)
concat_xy_row = np.concatenate((x, y), axis=0)
print("\nConcatenate x and y along rows:\n", concat_xy_row)

# Concatenate v and w along columns (horizontal stack)
concat_vw_col = np.column_stack((v, w))
print("\nConcatenate v and w along columns:\n", concat_vw_col)

import numpy as np
import time


# 1. Element-wise Addition


size = 1_000_000


list1 = list(range(size))
list2 = list(range(size))

start_time = time.time()
add_list = [a + b for a, b in zip(list1, list2)]
end_time = time.time()
print("Python List Addition Time:", end_time - start_time, "seconds")


arr1 = np.arange(size)
arr2 = np.arange(size)

start_time = time.time()
add_array = arr1 + arr2
end_time = time.time()
print("NumPy Array Addition Time:", end_time - start_time, "seconds")

# 2. Element-wise Multiplication



start_time = time.time()
mul_list = [a * b for a, b in zip(list1, list2)]
end_time = time.time()
print("\nPython List Multiplication Time:", end_time - start_time, "seconds")

start_time = time.time()
mul_array = arr1 * arr2
end_time = time.time()
print("NumPy Array Multiplication Time:", end_time - start_time, "seconds")

# 3. Dot Product


start_time = time.time()
dot_list = sum(a * b for a, b in zip(list1, list2))
end_time = time.time()
print("\nPython List Dot Product Time:", end_time - start_time, "seconds")


start_time = time.time()
dot_np = np.dot(arr1, arr2)
end_time = time.time()
print("NumPy Array Dot Product Time:", end_time - start_time, "seconds")

# 4. Matrix Multiplication



python_matrix_size = 200
numpy_matrix_size = 1000

mat1 = [[i+j for j in range(python_matrix_size)] for i in range(python_matrix_size)]
mat2 = [[i+j for j in range(python_matrix_size)] for i in range(python_matrix_size)]

start_time = time.time()
result_list = [
    [sum(mat1[i][k] * mat2[k][j] for k in range(python_matrix_size))
     for j in range(python_matrix_size)]
    for i in range(python_matrix_size)
]
end_time = time.time()
print(f"\nPython List Matrix Multiplication ({python_matrix_size}x{python_matrix_size}) Time:",
      end_time - start_time, "seconds")

matA = np.arange(numpy_matrix_size**2).reshape(numpy_matrix_size, numpy_matrix_size)
matB = np.arange(numpy_matrix_size**2).reshape(numpy_matrix_size, numpy_matrix_size)

start_time = time.time()
result_np = np.dot(matA, matB)
end_time = time.time()
print("NumPy Matrix Multiplication (1000x1000) Time:", end_time - start_time, "seconds")